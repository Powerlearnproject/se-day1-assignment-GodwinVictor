[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15690810&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering
NUMBER ONE
Explain what software engineering is and discuss its importance in the technology industry.
ANSWER: Software engineering is simply the systematic application of engineering approaches to the  planning, design, development, testing, and maintenance of software systems.
This aspect of engineering is very key in the technology industry because it helps to shape our digital life, drive technological advancements and make businesses to thrive.

NUMBER TWO
Identify and describe at least three key milestones in the evolution of software engineering.
ANSWER:  1968: The first NATO Software Engineering Conference is held.
1970s: A number of new methodologies are developed, including structured programming and object-oriented programming.
1980s: The first computer-aided software engineering (CASE) tools are released.

NUMBER THREE
List and briefly explain the phases of the Software Development Life Cycle.
ANSWER:
1. Planning & Analysis
The first phase of the SDLC is the project planning stage where you are gathering business requirements from your client or stakeholders.
2. Define Requirements
This phase is critical for converting the information gathered during the planning and analysis phase into clear requirements for the development team.
3. Design
The design phase is where you put pen to paper—so to speak. The original plan and vision are elaborated into a software design document (SDD) that includes the system design, programming language, templates, platform to use, and application security measures. This is also where you can flowchart how the software responds to user actions.

4. Development
The actual development phase is where the development team members divide the project into software modules and turn the software requirement into code that makes the product.

5. Testing
Before getting the software product out the door to the production environment, it’s important to have your quality assurance team perform validation testing to make sure it is functioning properly and does what it’s meant to do. The testing process can also help hash out any major user experience issues and security issues. 

6. Deployment
During the deployment phase, your final product is delivered to your intended user. You can automate this process and schedule your deployment depending on the type.

7. Maintenance
   In the maintenance stage, users may find bugs and errors that were missed in the earlier testing phase. These bugs need to be fixed for better user experience and retention. In some cases, these can lead to going back to the first step of the software development life cycle.

   
NUMBER FOUR
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
****Agile vs. Waterfall
Agile is an iterative approach to software development, emphasizing flexibility and collaboration among cross-functional teams. It focuses on delivering small, incremental releases, adapting to changes throughout the development process. 
In contrast, Waterfall is a linear and sequential approach, where each phase must be completed before moving to the next. Changes are difficult to incorporate once a phase is completed. Agile promotes adaptability and customer feedback, while Waterfall provides a structured plan but may struggle with accommodating changes late in the development cycle.
When it comes to software development methodologies, Agile and Waterfall are two prominent approaches that offer distinct advantages and challenges.
****When Agile is ideal:
Ideal for dynamic environments or projects with evolving requirements.
Suitable for startups, innovative products, and continuous improvement initiatives.
Requires active stakeholder involvement and dedicated resources.
******When Waterfall is ideal:
Preferable for projects with well-defined requirements and strict budgets or deadlines.
Commonly used in government contracts, large-scale infrastructure projects, and industries with regulatory compliance needs.
Offers predictability in project timelines and budgets, but may struggle with accommodating changes late in the development cycle.

NUMBER FIVE
Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
****SOFTWARE DEVELOPER
 A software developer responsible for designing, coding, testing, and deploying software applications using a variety of programming languages and technologies.
 ****QUALITY ASSURANCE ENGINEER
A Software Quality Assurance Engineers and Testers design test plans, scenarios, scripts, or procedures. Document software defects, using a bug tracking system, and report defects to software developers. Identify, analyze, and document problems with program function.
****PROJECT MANAGER
A Project Manager in Software Development is a crucial role responsible for overseeing the planning, execution and delivery of software projects. 


NUMBER SIX
Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
**An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Examples of an IDE include Visual Studio, Pycharm, Intelli j IDEA.

**Version control systems are software tools that help software teams manage changes to source code over time. As development environments have accelerated, version control systems help software teams work faster and smarter. It enables teams to work in distributed and asynchronous environments, manage changes and versions of code and artifacts, and resolve merge conflicts and related anomalies. Examples of version control systems include GIT, BITBUCKET, HELIX CORE etc.


NUMBER SEVEN
What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Software Engineering Challenges
It’s important to understand the major challenges faced by software engineers and devise a systematic roadmap to address each challenge as it arises. Whether it’s keeping up with the rapid advancement of technology or dealing with limited infrastructure and resources, software engineers are trained and develop the skill set needed to anticipate and overcome these types of challenges in the workplace. The experience gained helps professionals adjust and adapt to the ever-changing demands of the job. Some of the challenges faced by software engineers include:
1. Rapid Advancement of Technology
Technology evolves at a phenomenal rate and leads to added pressure for software engineers. From learning and staying up-to-date on concepts such as stack and JavaScript to writing code, software engineers juggle a variety of tasks to fulfill their duties. The ability to leverage tech trends in software product development gives professionals a cutting edge over competitors and allows them to stand out in a highly competitive market.
2. Growing Customer Demands
Software engineers generally work with conceptual projects designed and developed to meet varied customer demands. Even within the simplest application or product, software engineers must work toward understanding underlying business concepts and introduce required features to satisfy the needs of the consumer.
3. Time Constraints
Software engineering is time-consuming. Engineers work in high-pressure environments and must complete project requirements within tight deadlines. These demands may prove especially challenging when interacting with global customers across multiple time zones. These types of time constraints can impact a development team’s efficiency, leading to lower-quality end products.
4. Limited Infrastructure
Few resources or the lack of IT infrastructure to effectively execute projects effectively are some of challenges software engineers face in today’s tech landscape. Whether it's not having high-performance software engineering tools, computing platforms not operating to standards, inefficient data storage architectures, or improper networks and connectivity, software engineers rely heavily on infrastructure to perform their jobs effectively. When these components aren’t available or accessible, productivity among software development teams may be impacted and affect the overall results of a project or product.
5. Software Testing Conflicts
In traditional software engineering projects, it’s not uncommon for conflict to arise between software engineers and testers. Some of the factors that contribute to this type of interpersonal workplace challenge range from having to work under high-performance pressure, different mindsets on the quality of a product, differences in job roles, and the opposite nature of responsibilities between development and testing teams. Not controlling or managing testing conflicts effectively may impact the integrity of a project which can delay the release of a software system product or service.
6. Changing Requirements
Software requirements are often fluid and can change frequently. This can make it difficult to design and develop software that meets the needs of the users.  This is especially true when coming up with leading edge software.
7. Limited Time and Resources
Software development is often a time- and resource-constrained process. This can make it difficult to implement all of the security, scalability, reliability, and usability features that would be ideal.
8. Security
Writing secure software is a complex and challenging task. There are many different types of security vulnerabilities that can be exploited by attackers, and it can be difficult to keep up with the latest threats.
9. Scalability
Software that is not designed to scale can quickly become a bottleneck as the number of users or transactions increases. This can lead to performance problems, outages, and even data loss.  To write scalable software you need to consider multiple things: Use a scalable architecture, Use efficient algorithms and data structures; Reliability: Software that is not reliable can cause a great deal of frustration for users. Frequent crashes, errors, and downtime can lead to lost productivity, revenue, and customer goodwill.
10. High Availability
To build a highly available system you should use a scalable architecture,  use redundant components , use load balancing, use failover and have a disaster recovery plan
11. Usability
To build easy to use software you should do the following: keep it simple, design for the user, use consistent design, provide feedback and help.  

For all of these you need to test your software thoroughly,  and  monitor your software in production.

NUMBER EIGHT
Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit tests
Unit tests are very low level and close to the source of an application. They consist in testing individual methods and functions of the classes, components, or modules used by your software. Unit tests are generally quite cheap to automate and can run very quickly by a continuous integration server.

2. Integration tests
Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running.

3.System Testing
System testing, also referred to as system-level testing or system integration testing, is the process in which a quality assurance (QA) team evaluates how the various components of an application interact together in the full, integrated system or application.

4. Acceptance testing
Acceptance tests are formal tests that verify if a system satisfies business requirements. They require the entire application to be running while testing and focus on replicating user behaviors. But they can also go further and measure the performance of the system and reject changes if certain goals are not met.



#Part 2: Introduction to AI and Prompt Engineering

NUMBER ONE
Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering makes it easy for users to obtain relevant results in the first prompt. It helps mitigate bias that may be present from existing human bias in the large language models' training data. Further, it enhances the user-AI interaction so the AI understands the user's intention even with minimal input.

NUMBER TWO
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague Prompt: Speak french
Improved Prompt: Say Good morning in French

The first prompt is vague because the user is not specific on what he or she wants while the improved prompt is more direct and concise because the user is requesting for the french translation of Good morning.

